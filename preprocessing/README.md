## 1) Extracting feature types

First, we extract the features types present in the dataset. The extraction is done by parsing each file in feature_vectors folder, line by line, where we extract the feature type, finding chars before “::” occurs. Afterwards, it is checked if the feature type is a key to a dictionary and otherwise, it appends as a key with a numeric value. After this operation, we found 11 features types, which are feature, activity, intent, provider, call, api_call, url, permission, real_permission, service_receiver and an empty feature type. 

```
python3 extract_features.py
```   


| Feature Type Found | Feature Type | Class |
| ------------- | ------------- |  ------------- |
| provider | Hardware Components | S1 | 
| permission | Requested Permissions | S2 |
| activity | Components | S3 | 
| service_receiver | Components |	S3 | 
| intent | Intents | S4 |  
| call | Restricted Permissions | S5 | 
| real_permission |	Used Permissions | S6 | 
| api_call | Suspicious API Calls |	S7 | 
| url |	Network Addresses |	S8 | 
| feature | - | - | 


## 2) Counting features for each class

We use three dictionaries for this operation. The first one is predefined with keys, the feature types found in the previous step. With this dictionary, we extract the number, which corresponds to a class to increment a counter that counts the total features for a specific class. The second dictionary is used to check whether a feature in the form of feature_type::feature is present or not. We parse each file line by line, like in the previous step. For each feature found, which is unique, i.e., it has not inserted into the second dictionary, we check if this particular feature is in the dictionary and otherwise, we increment the counter for its corresponding class. 

```
python3 count_features_for_each_class.py
```  


| Class | Feature Type | Amount |
| ------------- | ------------- |  ------------- |
| S1 | provider | 4,513 |
| S2 | permission | 3,812 |
| S3 | activity | 185,729 |
| S3 | service_receiver | 33,222 |	
| S4 | intent | 6,379	|
| S5 | call | 733	|
| S6 | real_permission | 70 |	
| S7 | api_call | 315 |	
| S8 | url| 310,488 |
| - | feature | 72 |


## 3) Extracting top features

We parse all application’s feature vectors to get the top 10 features in malicious and benign apps separately to observe features with high support in both benign and malware applications. We iterate line by line, each malware application and each feature found is appended into a dictionary as a key with an integer value. The value increments by one for the same feature appearance. Similarly, the same procedure goes for benign applications.

```
python3 extract_feature_occurences.py
```  


| Top 10 malware features | Amount Malware | Amount Benign |
| ------------- | ------------- |  ------------- |
| feature::android.hardware.touchscreen | 5,524 | 123,178 |
| intent::android.intent.action.MAIN | 5,351 | 120,345 |
| permission::android.permission.INTERNET | 5,323| 102,986 |
| intent::android.intent.category.LAUNCHER | 5,224| 118,504 |	
| call::getSystemService | 5,185 | 104,538	|
| real_permission::android.permission.INTERNET | 4,992 | 103,434	|
| permission::android.permission.READ_PHONE_STATE | 4,931 | 45,085 |	
| real_permission::android.permission.READ_PHONE_STATE | 4,186 | 41,877 |	
| call::getDeviceId | 3,761 | 41,877 |
| permission::android.permission.WRITE_EXTERNAL_STORAGE | 3,713 | 45,244 |


## 4) Getting mean features

```
python3 mean.py
```  


A mean of 46.7 features present in benign applications, unlike malicious applications that have a mean of 61.7 features per application.
